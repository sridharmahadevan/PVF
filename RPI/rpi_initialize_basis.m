function vBasis = rpi_initialize_basis( cBasis, cSamples, cOpts, cBasisOpts )%% function vBasis = chain_initialize_basis( cBasis, cSamples )%% This function initializes the basis for the problem%% IN:%   cOpts   : structure containing the following fields%               [SizeRandomSubset]    : number of samples to extract from cSamples. Default: 800.%%%%% DEPENDENCIES:%   FastRoughSetDownsample,FastLaplacianDetEigs,FastSimpleNNInterp,DWPTree%% SC:%   MM  :   4/23/06%   MM  :   5/15/06 : revised, debugged. v.1.0%%% Copyright 2006%% Mauro Maggioni% mauro@math.duke.edu% www.math.yale.edu/~mmm82%if nargin<3,    cOpts = [];end;if nargin<4,    cBasisOpts = [];end;if ~isfield(cOpts,'SizeRandomSubset'),    cOpts.SizeRandomSubset = 800;endif ~isfield(cOpts,'IsDiscrete'),    cOpts.IsDiscrete = false;end;if isempty(findstr(cBasis,'eigen')) & isempty(findstr(cBasis,'dwt')),    return;    vBasis = cBasis;end;% Set the options for building the graphcBasisOpts.Action='SetOptions';lOpts = feval(cBasis,[],[],cBasisOpts);% Convert the samples into manageable array.% The indices of the points are organized as follows:%   from 1:length(cSamples)                                                         : cSamples.state%   from length(cSamples)+1:length(cSamples)+(# absorb. states)                     : cSamples(absorb. states).nextstate% By default absorb. states includes the last sample.lSamplePts = cat(1,cSamples.state);lSampleRewards = cat(1,cSamples.reward);% If the state space is discrete, identify the unique samples, and discard redundanciesif cOpts.IsDiscrete,    [lUniqueStates,lUniqueIdxs,lUniqueIdxsInv] = unique(lSamplePts);    lSamplePts = lUniqueStates;        lSampleRewards = lSampleRewards(lUniqueIdxs);    %[lUniqueStatesIdxs,lUniqueIdxsInv] = FastRoughSetDownsample( lSamplePts, 0.05 );    %lSamplePts = lSamplePts(lUniqueStatesIdxs,:);        %lSampleRewards = lSampleRewards(lUniqueStatesIdxs);end;% These are not all the points: there are also cSamples.nextstate. The only nextstate's which are different from state's are the ones at% absorbing stateslAbsorbIdxs = union(find(cat(1,cSamples.absorb)),length(cSamples));% Rescale the sampleslSamplePts = rpi_apply_rescaling( lSamplePts, lOpts.Rescaling );%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%domN = findstr(cBasis,'_');dom  = cBasis(1:(domN(1)-1));%figure(3);subplot(2,1,1); scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4), lSamplePtsSub(:,5), 'r.');%xlabel('Bike Verticle Angle', 'FontSize', 14); ylabel('BVA Vel.', 'FontSize', 14); zlabel('BVA Acc.', 'FontSize', 14); view(30,15);%subplot(2,1,2); scatter3(lSamplePtsSub(:,1),lSamplePtsSub(:,2), lSamplePtsSub(:,6), 'r.'); % view(30,40); %xlabel('Handlebar Angle', 'FontSize', 14); ylabel('HandleBar Ang. Vel','FontSize', 14); zlabel('Angle to Goal', 'FontSize', 14); view(-30,20);drawnow;% if (strcmpi(dom,'bicycle') == 1)% %    lSamplePts = [sin(lSamplePts(:,1)) cos(lSamplePts(:,1)) lSamplePts(:,2) sin(lSamplePts(:,3)) cos(lSamplePts(:,3)) lSamplePts(:,4:5) sin(lSamplePts(:,6)) cos(lSamplePts(:,6)) lSamplePts(:,7:11)];% % endif (strcmpi(dom,'acrobot2') == 1)   lSamplePts = [sin(lSamplePts(:,1)) cos(lSamplePts(:,1)) sin(lSamplePts(:,2)) cos(lSamplePts(:,2)) lSamplePts(:,3:4)];endif (strcmpi(dom,'cartpole') == 1)   lSamplePts = [lSamplePts(:,1:2), sin(lSamplePts(:,3)) cos(lSamplePts(:,3)) lSamplePts(:,4)];end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Extract a random subset if the number of samples is very largeif cOpts.SizeRandomSubset<size(lSamplePts,1),%     fprintf('Selecting subset...');    lSubSet = true;    if lOpts.DownsampleDelta<=0,    % Extract random subset        lSubSet = randperm(length(cSamples));        lSubSet = lSubSet(1:min([cOpts.SizeRandomSubset,length(cSamples)]));    else        lSubSet = FastRoughSetDownsample( lSamplePts,lOpts.DownsampleDelta );        %holdon;plot(lSamplePts(lSubSet,1),lSamplePts(lSubSet,2),'go');drawnow;    %    figure; plot(lSamplePts(lSubSet,1),lSamplePts(lSubSet,2),'go');drawnow;    end;    % Add the absorbing states, they're important and we want them in the random subset    lSubSet = union(lSubSet,length(cSamples)+1:length(lSamplePts));    lSamplePtsSub = lSamplePts(lSubSet,:);       %figure;plot(lSamplePts(:,1),lSamplePts(:,2),'.');%     fprintf('done.\n');else    lSubSet = false;    lSamplePtsSub = lSamplePts;    %figure;plot(lSamplePts(:,1),lSamplePts(:,2),'bo');drawnow;end;%if (strcmpi(dom,'bicycle') == 1)%    figure(3);subplot(2,1,1); scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4), lSamplePtsSub(:,5), 'r.');%    xlabel('Bike Verticle Angle', 'FontSize', 14); ylabel('BVA Vel.', 'FontSize', 14); zlabel('BVA Acc.', 'FontSize', 14); view(30,15);%    subplot(2,1,2); scatter3(lSamplePtsSub(:,1),lSamplePtsSub(:,2), lSamplePtsSub(:,6), 'r.'); % view(30,40); %    xlabel('Handlebar Angle', 'FontSize', 14); ylabel('HandleBar Ang. Vel', 'FontSize', 14); zlabel('Angle to Goal', 'FontSize', 14); view(-30,20);drawnow;%end; % if (strcmpi(dom,'bicycle') == 1)%     figure(3);subplot(2,2,1); scatter3(lSamplePtsSub(:,1),lSamplePtsSub(:,2), lSamplePtsSub(:,3), 'r.');%     xlabel('Sin(HBA)', 'FontSize', 11); ylabel('Cos(HBA)', 'FontSize', 11); zlabel('HBA AV', 'FontSize', 11); view(30,15);%     %     figure(3);subplot(2,2,2); scatter3(lSamplePtsSub(:,4),lSamplePtsSub(:,5), lSamplePtsSub(:,6), 'r.');%     xlabel('Sin(BVA)', 'FontSize', 11); ylabel('Cos(BVA)', 'FontSize', 11); zlabel('BVA Vel', 'FontSize', 11); view(30,15);%     %     figure(3);subplot(2,2,3); scatter3(lSamplePtsSub(:,4),lSamplePtsSub(:,5), lSamplePtsSub(:,7), 'r.');%     xlabel('Sin(BVA)', 'FontSize', 11); ylabel('Cos(BVA)', 'FontSize', 11); zlabel('BVA Acc.', 'FontSize', 11); view(30,15);%     %     figure(3); subplot(2,2,4); scatter3(lSamplePtsSub(:,8),lSamplePtsSub(:,9), lSamplePtsSub(:,7), 'r.'); % view(30,40); %     xlabel('Sin(GA)', 'FontSize', 11); ylabel('Cos(GA)', 'FontSize', 11); zlabel('BVA Acc.', 'FontSize', 11); view(-30,20);drawnow;% end; % if (strcmpi(dom,'acrobot2') == 1)%     figure(3);subplot(2,2,1); scatter3(lSamplePtsSub(:,1),lSamplePtsSub(:,2), lSamplePtsSub(:,5), 'r.');%     xlabel('Sin Theta 1', 'FontSize', 14); ylabel('Cos Theta 1', 'FontSize', 14); zlabel('Theta 1 AV', 'FontSize', 14); view(45,45);%     subplot(2,2,2); scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4), lSamplePtsSub(:,6), 'r.'); % view(30,40); %     xlabel('Sin Theta 2', 'FontSize', 14); ylabel('Cos Theta 2', 'FontSize', 14); zlabel('Theta 2 AV', 'FontSize', 14); view(45,45);%     drawnow;% end; % if (strcmpi(dom,'cartpole') == 1)% %      figure(3);subplot(2,1,1); % %      scatter(lSamplePtsSub(:,1),lSamplePtsSub(:,2), 'r.'); xlabel('Distance'); ylabel('Velocity'); % %      subplot(2,1,2); scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4),lSamplePtsSub(:,5), 'm.'); % %      xlabel('Sin Angle'); ylabel('Cos Angle'); zlabel('Angular Velocity'); drawnow;% %      %      figure(3);subplot(3,1,1);%      scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4),lSamplePtsSub(:,1), 'm.'); %      xlabel('Sin(Pole Angle)'); ylabel('Cos(Pole Angle)'); zlabel('Cart Distance'); drawnow;%      subplot(3,1,2);%      scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4),lSamplePtsSub(:,2), 'm.'); %      xlabel('Sin(Pole Angle)'); ylabel('Cos(Pole Angle)'); zlabel('Cart Velocity'); drawnow;%      subplot(3,1,3);%      scatter3(lSamplePtsSub(:,3),lSamplePtsSub(:,4),lSamplePtsSub(:,5), 'm.'); %      xlabel('Sin(Pole Angle)'); ylabel('Cos(Pole Angle)'); zlabel('Pole Ang. Vel.'); drawnow;% end; % if (strcmpi(dom,'pendulum') == 1)%     figure(3); set(gcf,'Position', [550,600,400,300]); %     scatter(lSamplePtsSub(:,1),lSamplePtsSub(:,2), 'r.'); %     figure(3);scatter(lSamplePts(:,1),lSamplePts(:,2), 'r.'); %     title([num2str(length(lSamplePtsSub)), ' Samples: Inverted Pendulum'], 'FontSize', 14); %     xlabel('Angle', 'FontSize', 14); ylabel('Angular Velocity', 'FontSize', 14); drawnow; % end; %   if (strcmpi(dom,'mcar') == 1)%       figure(3);set(gcf,'Position',[1000,500,400,400]); %       scatter(lSamplePtsSub(:,1),lSamplePtsSub(:,2), 'r.'); %       title([num2str(length(lSamplePtsSub)), ' Samples: Mountain Car'], 'FontSize', 14);%       xlabel('Position'); ylabel('Velocity'); drawnow; %   end;       if (strcmpi(dom,'mcarneg') == 1)      figure(3);set(gcf,'Position',[1000,500,400,400]);       scatter(lSamplePtsSub(:,1),lSamplePtsSub(:,2), 'r.');       title([num2str(length(lSamplePtsSub)), ' Samples: Mountain Car'], 'FontSize', 14);      xlabel('Position'); ylabel('Velocity'); drawnow;   end; % % JEFF ADDING THIS ON 12/21/2006 TO CREATE DISCRETE GRAPHS BASED ON ACTUAL TRANSITIONSif cOpts.IsDiscrete,   lOpts.Transitions = [cat(1,cSamples.state) cat(1,cSamples.nextstate)];endif (strcmpi(lOpts.NormalizationType,'kronmarkovtwo')==1)   kronDepth = log2(length(lOpts.BlockSize)+1);   % determine if kronDepth is an integer value   isDepthInt = (double(int32(kronDepth)) - kronDepth) == 0;   if (isDepthInt == 0)      error('rpi_initialize_basis:  Wrong number of elements in BlockSize.');   end   if (lOpts.BlockSize(1) == -1)      error('rpi_initialize_basis:  The first BlockSize must be > 0');   end   % Determine the minimum number of samples   minSamples = getMinNumSamples(lOpts.BlockSize, kronDepth, 1);   if (size(lSamplePtsSub,1) < minSamples)      error('rpi_initialize_basis:  Not enough samples for given BlockSize.');   end   % Determine if BlockSizes are consistent   isConsistent = getConsistency(lOpts.BlockSize, kronDepth);   if (isConsistent == 0)      error('rpi_initialize_basis:  Inconsistent factored sizes within BlockSize.');   end   numToRemove = mod(size(lSamplePtsSub,1), minSamples);   % remove these by randomly selecting points   if (numToRemove > 0)      % generate unique random numbers in range (1, size(lSamplePtsSub,1))      randIdx = [];      cnt = 0;      while (cnt < numToRemove)         randNum = ceil(rand * size(lSamplePtsSub,1));         if (cnt == 0)            randIdx = randNum;            cnt = cnt + 1;         else            if (~ismember(randNum, randIdx))               randIdx = [randIdx randNum];               cnt = cnt + 1;            end         end      end      % remove these indices from the samples      lSubSet       = setdiff( (1:size(lSamplePtsSub,1)), randIdx );      lSamplePtsSub = lSamplePtsSub(lSubSet,:);   endend% % JEFF ADDING THIS ON 1/26/2007 TO MAKE SURE KRONECKER GETS INTEGER SIZE DIMENSIONS% % if (strcmpi(lOpts.NormalizationType,'kronmarkovtwo')==1)%     %    numToRemove = mod(size(lSamplePtsSub,1), lOpts.BlockSize);% %    % remove these by randomly selecting points% %    if (numToRemove > 0)% %       % generate unique random numbers in range (1, size(lSamplePtsSub,1))% %       randIdx = [];% %       cnt = 0;% %       while (cnt < numToRemove)% %          randNum = ceil(rand * size(lSamplePtsSub,1));% %          if (cnt == 0)% %             randIdx = randNum;% %             cnt = cnt + 1;% %          else% %             if (~ismember(randNum, randIdx))% %                randIdx = [randIdx randNum];% %                cnt = cnt + 1;% %             end% %          end% %       end% %       % remove these indices from the samples% %       lSubSet       = setdiff( (1:size(lSamplePtsSub,1)), randIdx );% %       lSamplePtsSub = lSamplePtsSub(lSubSet,:);%       %       fprintf('Removed %d samples to get Kronecker rounding\n', numToRemove); % %    end% % end% Compute graph Laplacian and eigenfunctions on the subsampled graph% fprintf('Constructing graph on %d points and computing %d eigenfunctions...\n',size(lSamplePtsSub,1),lOpts.MaxEigenVals);[vGraph, vEigenVecsSub, vEigenVals, vOpts, vLaplacian, vNNInfo,vDiffusion,vQ] = FastLaplacianDetEigs( lSamplePtsSub, lOpts );% SRIDHAR: reset basis to Krylov basis! 1/30/08%vEigenVecsSub = vQ(:,1:25)'; %figure; plot(1-vEigenVals, 'LineWidth', 2); title('Spectrum of Powers of Diffusion Operator'); hold on; %[vEigenvec2, vEigenVals2] = eigs(vLaplacian^2,size(vEigenVals,1), 'sa'); %plot(1-sort(diag(vEigenVals2)), 'r', 'LineWidth', 2); %[vEigenvec4, vEigenVals4] = eigs(vLaplacian^4,size(vEigenVals,1), 'sa');  hold on; %plot(1-sort(diag(vEigenVals4)), 'm', 'LineWidth', 2); %drawnow; pause; % figure(1); subplot(3,1,2); spy(vGraph.W);% title(['W: ' num2str(length(lSamplePtsSub)), ' Data: ' num2str(length(lSamplePts))], 'FontSize', 14); drawnow;% if (strcmpi(dom,'acrobot2') == 1)%     figure(3);subplot(2,2,3); scatter3(vEigenVecsSub(2,:),vEigenVecsSub(3,:), vEigenVecsSub(4,:), 'r.');%     title('Acrobot Embedding', 'FontSize', 14); %     subplot(2,2,4); scatter3(vEigenVecsSub(5,:),vEigenVecsSub(6,:), vEigenVecsSub(7,:), 'r.');%     title('Acrobot Embedding', 'FontSize', 14);  drawnow; % end; % fprintf('\n');% SRIDHAR: added an extra component for Krylov bases% if (strcmpi(lOpts.NormalizationType,'krylov')==1)%          %     [vKrylovBases] = compute_krylov_bases(vLaplacian,rand(size(vLaplacian,1),1),lOpts.MaxEigenVals); %     %     disp(size(vKrylovBases)); %     %     vEigenVecsSub = vKrylovBases; %     %    vEigenVecsSub = [vEigenVecsSub(1:5,:)',vKrylovBases(1:lOpts.MaxEigenVals-5,:)']'; %     disp(size(vEigenVecsSub)); %   % end; % % if cOpts.IsDiscrete,    % TODO: this shouldn't be here if we subsample later on....    % Replace the samples by their indices%size(lSamplePts) % 200x1    lSamplePts = 1:size(lSamplePts,1);%size(lSamplePts) % 1x200end;% Prepare a structure with info to be passed to the domain_basis_typeofbasis functionlBasis.Opts      = vOpts;lBasis.Graph     = vGraph;lBasis.NNInfo    = vNNInfo;lBasis.Points    = lSamplePts;lBasis.PointsSub = lSamplePtsSub;if cOpts.IsDiscrete,    lBasis.MapPointsToIdxs = lUniqueIdxsInv;                 % THIS IS KEY, HOW DOES THIS GET USED LATER ON???end;if ~isempty(findstr(cBasis,'eigen')),    % Extend the eigenfunctions to the full graph.        if (strcmpi(lOpts.NormalizationType,'kronmarkovtwo')==1)%        if lSubSet,        vNNInfo.kNN = lOpts.kNN;        vNNInfo.Delta = lOpts.Delta;%        end        lBasis.Basis = [];                       % don't calculate this now (save the memory)        lBasis.BasisSub = vEigenVecsSub;         % this is a cell array        lBasis.EigenVals = vEigenVals;        % Create a data file with all the basis functions in it%        fprintf('Extending the eigenfunctions...');        FastSimpleNNInterpKron(lSamplePtsSub, lSamplePts, vEigenVecsSub, vNNInfo, 'initialize');        fprintf('\n');    else                if lSubSet,%            fprintf('Extending the eigenfunctions...');            vNNInfo.kNN = lOpts.kNN;            vNNInfo.Delta = lOpts.Delta;            vEigenVecs = FastSimpleNNInterp( lSamplePtsSub, lSamplePts, vEigenVecsSub, vNNInfo );            % TODO: THIS IS WRONG IN THE DISCRETE CASE: I WANT THE LSAMPLEPTS TO BE SORTED            fprintf('\n'); % figure;scatter(lSamplePtsSub(:,1),lSamplePtsSub(:,2),5,vEigenVecs2(4,:));hold on;scatter(lSamplePts(:,1),lSamplePts(:,2),2,vEigenVecs(3,:));        else            vEigenVecs = vEigenVecsSub;        end;        lBasis.Basis = vEigenVecs;        lBasis.EigenVals = vEigenVals;        lBasis.BasisSub = vEigenVecsSub;    end            elseif ~isempty(findstr(cBasis,'dwt')),        % convert to tridiagonal Hessenberg matrix    %    figure(5); subplot(2,1,1); imagesc(vLaplacian);   %[vLaplacian, vQ] = lanczos_red(vLaplacian,rand(size(vLaplacian,1),1),1e-10,lOpts.MaxEigenVals);%    figure(5); subplot(2,1,2); imagesc(vLaplacian); drawnow;    % Construct the diff. wavelet basis %   fprintf('Constructing diffusion wavelet tree on %d points...\n', size(vLaplacian,1));        %[lDWTree] = DiffusionWaveletTree ( 'Partial', lDWTOpts,    %speye(size(vLaplacian)), speye(size(vLaplacian))-vLaplacian,    %lDWTOpts.Levels, 1e-4);         lDWTree = DWPTree_Fast((speye(size(vLaplacian))-vLaplacian)^2, lOpts.Levels, lOpts.Epsilon, lOpts);     %     lDWTree = DWPTree_Full_Lanczos((speye(size(vLaplacian))-vLaplacian)^2, vQ,lOpts.Levels, lOpts.Epsilon, lOpts);%      for i=1:length(lDWTree) %          fprintf('%d Scaling functions at level %d\n', size(lDWTree{i}.ExtBasis,2), i); %          fprintf('\t %d Wavelets at level %d\n', size(lDWTree{i,2}.ExtBasis,2), i);%      end;%        % display_dwt_operator2(lDWTree); pause;       %   [vLaplacian, vQ] = lanczos_red(vLaplacian,rand(size(vLaplacian,1),1),1e-10,lOpts.MaxEigenVals);    % Now extract and expand the desired basis functions    % First of all calculate how many basis functions will exist, so that memory can be pre-allocated        lDWTBasisN = size(lDWTree{size(lDWTree,1),1}.ExtBasis,2);        for lj = size(lDWTree,1):-1:lOpts.MinLevel,        lDWTBasisN = lDWTBasisN + size(lDWTree{lj,2}.ExtBasis,2);    end;    %    if vOpts.Lanczos        %        lDWTBasis = zeros(lDWTBasisN,size(vQ,1)); % size(vLaplacian,1));  vLaplacian has grown smaller!        %else        lDWTBasis = zeros(lDWTBasisN,size(vLaplacian,1));%    end;        lIdx = size(lDWTree{size(lDWTree,1),1}.ExtBasis,2);        %     %     if vOpts.Lanczos%         lDWTBasis(1:lIdx,:) = (vQ*lDWTree{size(lDWTree,1),1}.ExtBasis)';%     else         lDWTBasis(1:lIdx,:) = lDWTree{size(lDWTree,1),1}.ExtBasis';  %  end;     %    lIdx2 = size(lDWTree{size(lDWTree,1)-1,1}.ExtBasis,2);    %    fprintf('Adding DWT basis %d scaling functions\n', lIdx);    %    lDWTBasis(lIdx+1:lIdx2,:) = lDWTree{size(lDWTree,1)-1,1}.ExtBasis';    %    lIdx = lIdx + lIdx2;    for lj = size(lDWTree,1):-1:lOpts.MinLevel,        if vOpts.Lanczos            lDWTBasis(lIdx+1:lIdx+size(lDWTree{lj,2}.ExtBasis,2),:) = (vQ*lDWTree{lj,2}.ExtBasis)';        else             lDWTBasis(lIdx+1:lIdx+size(lDWTree{lj,2}.ExtBasis,2),:) =   lDWTree{lj,2}.ExtBasis';        end; %        fprintf('Adding to DWT basis %d wavelets\n', size(lDWTree{lj,2}.ExtBasis,2));         lIdx = lIdx+size(lDWTree{lj,2}.ExtBasis,2);                if lIdx > lOpts.MaxFunctions             break        end;     end;    fprintf('\n');    lN = min([size(lDWTBasis,1),lOpts.MaxFunctions]);    lDWTBasis = lDWTBasis(1:lN,:);     % Extend the eigenfunctions to the full graph.    if lSubSet,%        fprintf('Extending the diffusion wavelets...');        vNNInfo.kNN = lOpts.kNN;        vNNInfo.Delta = lOpts.Delta;        lDWTBasisExt = FastSimpleNNInterp( lSamplePtsSub, lSamplePts, lDWTBasis, vNNInfo );        % TODO: THIS IS WRONG IN THE DISCRETE CASE: I WANT THE LSAMPLEPTS TO BE SORTED        fprintf('\n');    else        lDWTBasisExt = lDWTBasis;    end;    lBasis.Tree     = lDWTree;    lBasis.DWTOpts  = lOpts;    lBasis.BasisSub    = lDWTBasis;    lBasis.Basis       = lDWTBasisExt;else    fprintf('Warning: rpi_initialize_basis could not recognized the basis type to be built!\n');end;% Call the basis function to initialize it and create persistent variableslBasis.Action = 'Initialize';feval( cBasis, [],[], lBasis );vBasis = cBasis;return;